package edu.bath.matchmaker;

import com.google.common.base.Function;
import com.google.common.base.Preconditions;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableMultiset;
import com.google.common.collect.ImmutableSet;
import com.google.common.collect.Maps;
import com.google.common.collect.Multiset;
import edu.bath.matchmaker.MatchDecorator.Decoration;
import edu.bath.matchmaker.OwlsUtils.Parameters;
import edu.bath.matchmaker.prefs.Preference;
import edu.bath.matchmaker.similarity.DocumentManager;
import edu.bath.matchmaker.similarity.Similarity;
import edu.bath.matchmaker.similarity.TermWeights;
import edu.bath.matchmaker.similarity.TextType;
import java.io.ObjectInputStream;
import java.io.Serializable;
import java.net.URI;
import java.util.Collection;
import java.util.Collections;
import java.util.EnumMap;
import java.util.List;
import java.util.Set;
import org.mindswap.owls.profile.Profile;
import org.mindswap.owls.process.Process;
import org.mindswap.owls.process.Result;
import org.mindswap.owls.service.Service;
import org.mindswap.swrl.Atom;
import org.mindswap.swrl.ClassAtom;
import org.mindswap.swrl.DataPropertyAtom;
import org.mindswap.swrl.IndividualPropertyAtom;
import static edu.bath.matchmaker.similarity.TextUtils.*;
import org.mindswap.owls.expression.Condition;
import org.mindswap.owls.expression.Expression;

/**
 * This class offer various nested {@link MatchDecorator decorator} implementations which can be applied to the {@link MatchMaker#MatchMaker(List)}
 * constructor so that they can optionally add attributes (decorations) to all {@link Match}es generated by
 * that matchmaker.
 *
 * <p>
 * For example, to create a {@code MatchMaker} that automatically decorates matches with syntactic
 * similarity measures, use this:
 *<pre>{@code
 *  MatchMaker matchMaker = new MatchMaker(new Decorators.DescriptionSimilarityDecorator());
 *}</pre>
 *
 * <p>See each offered decorator class for details on which key it uses to add each decoration.
 *
 * @see MatchDecorator
 * @see MatchMaker#match(OWLOntology, InputMatcher, OutputMatcher)
 * @see MatchMaker#match(OWLOntology, InputMatcher, OutputMatcher, Predicate)
 * @author Andreou Dimitris, email: jim.andreou (at) gmail.com
 */
public class Preferences {
    private Preferences() { }

    private static final <T> Function<Match, T> valueExtractorFor(final Decoration key, final Class<T> type) {
        return new Function<Match, T>() {
            public T apply(Match match) {
                Object o = match.getDecoration(key);
                if (o == null) {
                    throw new IllegalStateException("Match: " + match + " does not have a " + key + " decoration (of class " + key.getClass() + ") - did you initialize the " +
                            MatchMaker.class.getSimpleName() + " that generated it with the appropriate " + MatchDecorator.class.getSimpleName() +
                            " which would add this attribute?");
                }
                return type.cast(o);
            }

            @Override
            public String toString() {
                return "get(" + key + ")";
            }
        };
    }

    /**
     * Decoration of textual similarity scores, consisting of a {@link TextType}
     * instance and a {@link Similarity} instance, both non-null.
     */
    public static class TextualSimilarity implements Decoration, Serializable {
        private static final long serialVersionUID = 0L;

        private final TextType textType;
        private final Similarity similarity;

        /**
         * Creates a TextualSimilarity by a {@link TextType} instance and a {@link Similarity} instance.
         *
         * @param textType the type of text for which a similarity measure is applied
         * @param similarity the similarity measure applied to some text
         */
        public TextualSimilarity(TextType textType, Similarity similarity) {
            this.textType = Preconditions.checkNotNull(textType);
            this.similarity = Preconditions.checkNotNull(similarity);
        }

        @Override
        public int hashCode() {
            return 31 + 31 * textType.hashCode() + 31 * 31 * similarity.hashCode();
        }

        /**
         * Compares two {@code TextualSimilarity}s for equality. The result is true if and only if the
         * argument is not {@code null} and is a {@code TextualSimilarity} object which consists of
         * the same {@link #textType() text type} and {@link #similarity() similarity} as this one.
         *
         * @param o the object to compare with
         * @return whether the objects are equal
         */
        @Override
        public boolean equals(Object o) {
            if (!(o instanceof TextualSimilarity)) return false;
            TextualSimilarity that = (TextualSimilarity)o;
            return this.textType == that.textType && this.similarity == that.similarity;
        }

        @Override
        public String toString() {
            return "[" + textType + ", " + similarity + "]";
        }

        /**
         * Returns the {@link TextType} of this object.
         *
         * @return the {@code TextType} of this object
         */
        public TextType textType() {
            return textType;
        }

        /**
         * Returns the {@link Similarity} of this object.
         *
         * @return the {@code Similarity} of this object
         */
        public Similarity similarity() {
            return similarity;
        }

        private transient Preference<Match> preference = initPartialOrder();
        public Preference<Match> preference() {
            return preference;
        }

        private Preference<Match> initPartialOrder() {
            return Preference.natural().reverse().onResultOf(valueExtractorFor(this, Double.class));
        }

        private void readResolve(ObjectInputStream s) throws Exception {
            s.defaultReadObject();
            preference = initPartialOrder();
        }
    }

    private static abstract class AbstractSimilarityDecorator implements MatchDecorator, Serializable {
        private final DocumentManager docManager = new DocumentManager();
        private final ImmutableList<TextualSimilarity> keys;

        private static final long serialVersionUID = 0L;

        public AbstractSimilarityDecorator(TextType textType) {
            Similarity[] sims = Similarity.values();
            ImmutableList.Builder<TextualSimilarity> builder = ImmutableList.<TextualSimilarity>builder();

            for (Similarity similarity : sims) {
                builder.add(new TextualSimilarity(textType, similarity));
            }
            this.keys = builder.build();
        }

        public void onRegistration(MatchMaker matchMaker, ServiceDescriptor serviceDescriptor, Service service) {
            Iterable<String> tokens = extractTerms(service);

            docManager.addDocument(service.getURI(), tokens);
        }

        public void onDeregistration(MatchMaker matchMaker, ServiceDescriptor serviceDescriptor) {

        }

        public void decorate(MatchMaker matchMaker, Subsumption<URI> subsumption,
                ServiceDescriptor queryDescriptor, Service query, List<? extends Match> matches) {
            Multiset<String> queryTerms = ImmutableMultiset.copyOf(extractTerms(query));
            for (Match match : matches) {
                Multiset<String> serviceTerms = docManager.documentTerms(match.getService().getURI());

                for (TextualSimilarity similarityKey : keys) {
                    double score = similarityKey.similarity.similarity(docManager.weights(serviceTerms), docManager.weights(queryTerms));
                    match.putDecoration(similarityKey, score);
                }
            }
        }

        public Collection<TextualSimilarity> providedDecorations() {
            return keys;
        }

        protected abstract Iterable<String> extractTerms(Service service);
    }

    /**
     * A {@link MatchDecorator} implementation which decorates service matches according
     * to the syntactical (textual) similarity of their profile's descriptions, compared to the respective
     * description of the query. The scores are added using {@link TextualSimilarity} instances with a text type of {@link TextType#DESCRIPTION},
     * and <em>all</em> {@link Similarity} constants.
     *
     * <p>This implementation holds in main memory all words (except stopwords) of the descriptions of registered services.
     *
     * @see TextualSimilarity
     */
    public static class DescriptionSimilarityDecorator implements MatchDecorator, Serializable {
        private static final long serialVersionUID = 0L;

        private AbstractSimilarityDecorator helper = new AbstractSimilarityDecorator(TextType.DESCRIPTION) {
            @Override
            protected Iterable<String> extractTerms(Service service) {
                Profile profile = service.getProfile();
                if (profile == null) return Collections.<String>emptySet();
                String description = profile.getTextDescription();
                if (description == null) return Collections.<String>emptySet();
                return stem(filterStopwords(toLowerCase(tokenize(description))));
            }
        };

        /**
         * Creates a new instance of {@code DescriptionSimilarityDecorator}.
         */
        public DescriptionSimilarityDecorator() {
        }

        public void decorate(MatchMaker matchMaker, Subsumption<URI> subsumption,
                ServiceDescriptor queryDescr, Service query, List<? extends Match> match) {
            helper.decorate(matchMaker, subsumption, queryDescr, query, match);
        }

        public void onRegistration(MatchMaker matchMaker, ServiceDescriptor serviceDescr, Service service) {
            helper.onRegistration(matchMaker, serviceDescr, service);
        }

        public void onDeregistration(MatchMaker matchMaker, ServiceDescriptor serviceDescr) {
            helper.onDeregistration(matchMaker, serviceDescr);
        }

        /**
         * Returns all provided {@link TextualSimilarity} instances of this decorator, which are
         * all the combinations of {@link Similarity similarities} with the {@link TextType#DESCRIPTION} text type.
         *
         * @return all provided {@code TextualSimilarity} instances of this decorator
         */
        public Collection<TextualSimilarity> providedDecorations() {
            return helper.providedDecorations();
        }
    }

    /**
     * A {@link MatchDecorator} implementation which decorates service matches according
     * to the syntactical (textual) similarity of their profile's postconditions, compared to the respective
     * description of the query. The scores are added using {@link TextualSimilarity} instances with a text type of {@link TextType#PRECONDITIONS},
     * and <em>all</em> {@link Similarity} constants.
     *
     * <p>This implementation holds in main memory all terms (URIs) of the postconditions of registered services.
     *
     * @see TextualSimilarity
     */
    public static class PreconditionSimilarityDecorator implements MatchDecorator, Serializable {
        private static final long serialVersionUID = 0L;

        private AbstractSimilarityDecorator helper = new AbstractSimilarityDecorator(TextType.PRECONDITIONS) {
            @Override
            protected Iterable<String> extractTerms(Service service) {
                Process process = service.getProcess();
                if (process == null) {
                    return ImmutableMultiset.<String>of();
                }

                ImmutableMultiset.Builder<String> builder = ImmutableMultiset.builder();
                for (Condition condition : process.getConditions()) {
                    collectTerms(condition.getBody(), builder);
                }
                return builder.build();
            }
        };

        /**
         * Creates a new instance of {@code PreconditionSimilarityDecorator}.
         */
        public PreconditionSimilarityDecorator() {
        }

        public void decorate(MatchMaker matchMaker, Subsumption<URI> subsumption,
                ServiceDescriptor queryDescr, Service query, List<? extends Match> match) {
            helper.decorate(matchMaker, subsumption, queryDescr, query, match);
        }

        public void onRegistration(MatchMaker matchMaker, ServiceDescriptor serviceDescr, Service service) {
            helper.onRegistration(matchMaker, serviceDescr, service);
        }

        public void onDeregistration(MatchMaker matchMaker, ServiceDescriptor serviceDescr) {
            helper.onDeregistration(matchMaker, serviceDescr);
        }

        /**
         * Returns all provided {@link TextualSimilarity} instances of this decorator, which are
         * all the combinations of {@link Similarity similarities} with the {@link TextType#PRECONDITIONS} text type.
         *
         * @return all provided {@code TextualSimilarity} instances of this decorator
         */
        public Collection<TextualSimilarity> providedDecorations() {
            return helper.providedDecorations();
        }
    }

    /**
     * A {@link MatchDecorator} implementation which decorates service matches according
     * to the syntactical (textual) similarity of their profile's preconditions, compared to the respective
     * description of the query. The scores are added using {@link TextualSimilarity} instances with a text type of {@link TextType#POSTCONDITIONS},
     * and <em>all</em> {@link Similarity} constants.
     *
     * <p>This implementation holds in main memory all terms (URIs) of the preconditions of registered services.
     *
     * @see TextualSimilarity
     */
    public static class PostconditionSimilarityDecorator implements MatchDecorator, Serializable {
        private static final long serialVersionUID = 0L;

        private AbstractSimilarityDecorator helper = new AbstractSimilarityDecorator(TextType.POSTCONDITIONS) {
            @Override
            protected Iterable<String> extractTerms(Service service) {
                ImmutableMultiset.Builder<String> builder = ImmutableMultiset.builder();
                for (Result result : service.getProcess().getResults()) {
                    for (Expression effect : result.getEffects()) {
                        collectTerms(effect.getBody(), builder);
                    }
                }
                return builder.build();
            }
        };

        /**
         * Creates a new instance of {@code PostconditionSimilarityDecorator}.
         */
        public PostconditionSimilarityDecorator() {
        }

        public void decorate(MatchMaker matchMaker, Subsumption<URI> subsumption,
                ServiceDescriptor queryDescr, Service query, List<? extends Match> match) {
            helper.decorate(matchMaker, subsumption, queryDescr, query, match);
        }

        public void onRegistration(MatchMaker matchMaker, ServiceDescriptor serviceDescr, Service service) {
            helper.onRegistration(matchMaker, serviceDescr, service);
        }

        public void onDeregistration(MatchMaker matchMaker, ServiceDescriptor serviceDescr) {
            helper.onDeregistration(matchMaker, serviceDescr);
        }

        /**
         * Returns all provided {@link TextualSimilarity} instances of this decorator, which are
         * all the combinations of {@link Similarity similarities} with the {@link TextType#POSTCONDITIONS} text type.
         *
         * @return all provided {@code TextualSimilarity} instances of this decorator
         */
        public Collection<TextualSimilarity> providedDecorations() {
            return helper.providedDecorations();
        }
    }

    static void collectTerms(Object objs, ImmutableMultiset.Builder<String> set) {
        List<Atom> atoms = (List<Atom>)objs;
        for (int i = 0; i < atoms.size(); i++) {
            Atom atom = atoms.get(i);
            final URI uri;
            if (atom instanceof ClassAtom) {
                uri = ((ClassAtom)atom).getClassPredicate().getURI();
            } else if (atom instanceof DataPropertyAtom) {
                uri = ((DataPropertyAtom)atom).getPropertyPredicate().getURI();
            } else if (atom instanceof IndividualPropertyAtom) {
                uri = ((IndividualPropertyAtom)atom).getPropertyPredicate().getURI();
            } else {
                throw new AssertionError("Unexpected atom type, please report: " + atom.getClass());
            }
            set.add(uri.toString());
        }
    }

    /**
     * Parameter (input or output) exactness decoration keys.
     */
    public enum ParamExactness implements Decoration {
        /**
         * Key for the number of inexact inputs of a service (compared to the query's inputs), used by {@link ParamExactnessDecorator}.
         */
        INPUTS,

        /**
         * Key for the number of inexact outputs of a service (compared to the query's outputs), used by {@link ParamExactnessDecorator}.
         */
        OUTPUTS,

        /**
         * Key for the number of inexact inputs and outputs of a service (compared to the query's inputs and outputs), used by {@link ParamExactnessDecorator}.
         */
        INPUTS_OUTPUTS() {
            @Override
            public Preference<Match> preference() {
                return composite;
            }
        };

        private static final Preference<Match> composite = Preference.consensus(
                INPUTS.preference, OUTPUTS.preference);

        private final Preference<Match> preference = Preference.natural().reverse().onResultOf(valueExtractorFor(this, Double.class));
        public Preference<Match> preference() {
            return preference;
        }
    }

    /**
     * A (singleton) {@link MatchDecorator} implementation which counts how many inputs and outputs
     * of a service have inexactly matched corresponding inputs and outputs of a query, storing the results using
     * {@link ParamExactness} keys. For example, if a query defines an input of type {@code INP}, then if
     * the corresponding service input is {@code INP}, then it matched exactly, otherwise if it is some superclass of {@code INP},
     * then it matched inexactly. Similarly for outputs, where a service output could match exactly a query output, or it could
     * match it inexactly by a subclass of it. These counts are turned to negative numbers.
     *
     * <p>Precisely, the attributes created by this decorator are:
     * <ul>
     * <li>zero minus the number of service inputs with types matching inexactly a query input, by the {@code ParamExactness.INPUTS} key
     * <li>zero minus the number of service outputs with types matching inexactly matching a query outputs, by the {@code ParamExactness.OUTPUTS} key
     * <li>the sum of the above, for convenience, by the {@code ParamExactness.INPUTS_OUTPUTS} key
     * </ul>
     *
     * <p>Thus, the maximum value that these measures can have is zero. If a measure
     * (for example {@code ParamExactness.INPUTS}) is zero, then the respective
     * match was perfect: all types were matched exactly. A negative value means that there were some inexact
     * matches, and the more inexact matches, the less the value. This is done for achieve two goals:
     * <ul>
     * <li>To treat bigger values as better, as the values produced by the other decorators
     * <li>To be able to easily test whether a match (its inputs, outputs, or both) was exact or not
     * (without having to count the inputs/outputs of the query), simply by comparing to zero
     * </ul>
     */
    public static class ParamExactnessDecorator implements MatchDecorator, Serializable {
        private static final long serialVersionUID = 0L;

        private static final EnumMap<Parameters, ParamExactness> paramsTypeToKey = Maps.newEnumMap(Parameters.class); static {
            paramsTypeToKey.put(Parameters.INPUT, ParamExactness.INPUTS);
            paramsTypeToKey.put(Parameters.OUTPUT, ParamExactness.OUTPUTS);
        }

        public ParamExactnessDecorator() { }

        public void decorate(MatchMaker matchMaker, Subsumption<URI> subsumption,
                ServiceDescriptor queryDescr, Service query, List<? extends Match> match) {
            for (Parameters params : OwlsUtils.Parameters.values()) {
                Set<URI> exactTypesOfQuery = ImmutableSet.copyOf(params.parametersOf(queryDescr));
                TermWeights<URI> queryTerms = TermWeights.equallyWeighted(exactTypesOfQuery);
                for (Match m : match) {
                    TermWeights<URI> serviceTerms = TermWeights.equallyWeighted(ImmutableSet.copyOf(params.parametersOf(m.getService())));
                    double similarity = edu.bath.matchmaker.similarity.Similarity.JACCARD.similarity(queryTerms, serviceTerms);

                    ParamExactness key = paramsTypeToKey.get(params);
                    m.putDecoration(key, similarity);
                }
            }
        }

        public void onRegistration(MatchMaker matchMaker, ServiceDescriptor serviceDescriptor, Service service) {
        }

        public void onDeregistration(MatchMaker matchMaker, ServiceDescriptor serviceDescr) {
        }

        public Collection<ParamExactness> providedDecorations() {
            return ImmutableList.of(ParamExactness.values());
        }
    }

    /**
     * Decorations that prefer matched services with more specific inputs or outputs (or both) rather
     * than less specific ones. In particular, if a service {@linkplain #inputs(Subsumption) inputs} (or, respectively,
     * {@linkplain #outputs(Subsumption) outputs}, or {@linkplain #inputsOutputs(Subsumption) inputs/outputs}) are not
     * a superclass of another service's inputs (thus no input of the other service is more specific), and there is
     * at least one input which is a subclass of an input of the other service (i.e. more specific), then this
     * service is preferred as being more specific.
     *
     * <p>Note: the constants defined in this class can be used directly, there is no need for a
     * {@code MatchDecorator} attached to a {@code MatchMaker}, since no attribute
     * is needed to be constructed, any {@link Match} instance alone contains all the information needed to define
     * these partial orderings.
     *
     */
    public static class ParamSpecialization {
        private ParamSpecialization() { throw new AssertionError(); }

        private static final Preference<Set<URI>> setOfClassPartialOrder(final Subsumption<URI> subsumption) {
            return new Preference<URI>() {
                @Override
                public boolean equalOrBetter(URI o1, URI o2) {
                    return subsumption.subsumedBy().isRelated(o1, o2);
                }

                @Override
                public String toString() {
                    return "PreferSpecializedParams";
                }
            }.lift();
        }

        /**
         * Prefers services with more specific input parameters.
         */
        public static Preference<Match> inputs(Subsumption<URI> subsumption) {
            return setOfClassPartialOrder(subsumption).onResultOf(new Function<Match, Set<URI>>() {
                public Set<URI> apply(Match match) {
                    return match.getService().getInputTypes();
                }

                @Override
                public String toString() {
                    return "getInputs()";
                }
            });
        }

        /**
         * Prefers services with more specific output parameters.
         */
        public static Preference<Match> outputs(Subsumption<URI> subsumption) {
            return setOfClassPartialOrder(subsumption).onResultOf(new Function<Match, Set<URI>>() {
                public Set<URI> apply(Match match) {
                    return match.getService().getOutputTypes();
                }

                @Override
                public String toString() {
                    return "getOutputs()";
                }
            });
        }

        /**
         * Prefers services with more specific input and output parameters.
         */
        public static Preference<Match> inputsOutputs(Subsumption<URI> subsumption) {
            return Preference.consensus(inputs(subsumption), outputs(subsumption));
        }
    }
}
